<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="robots" content="noindex, nofollow">
  <title>üéµüé§üé∂</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600;900&display=swap" rel="stylesheet">
  <style>
    body {
      background: radial-gradient(circle at top, #0a0a2a 0%, #000 80%);
      color: #fff;
      font-family: 'Orbitron', sans-serif;
      text-align: center;
      margin: 0;
      min-height: 100vh;
      overflow-x: hidden;
      position: relative;
      z-index: 0;
    }

    /* üåÜ Skyline con tu imagen */
	body::before {
	  content: "";
	  position: absolute;
	  inset: 0;
	  background: url("bck.png") 
				  no-repeat bottom center;
	  background-size: cover;
	  z-index: -3; /* m√°s al fondo */
	  filter: brightness(0.6) 
			  drop-shadow(0 0 15px #00eaff) 
			  drop-shadow(0 0 30px #0077ff);
	}

	/* üîµ Grid azul animado */
	body::after {
	  content: "";
	  position: absolute;
	  inset: 0;
	  background:
		linear-gradient(to right, rgba(0,220,255,0.8) 2px, transparent 2px),
		linear-gradient(to top, rgba(0,220,255,0.8) 2px, transparent 2px);
	  background-size: 50px 50px; /* mantiene tama√±o celda */
	  transform: perspective(700px) rotateX(47deg)  scaleX(5) scaleY(2);
	  transform-origin: bottom;
	  animation: gridmove 4s linear infinite;
	  z-index: -2; /* encima del skyline, debajo del contenido */
	  opacity: 0.8;
	}


    @keyframes gridmove {
      from { background-position-y: 0; }
      to   { background-position-y: 100px; }
    }

    h1 {
      font-size: 3.2em;
      color: #00eaff;
      text-shadow: 0 0 15px #00eaff, 0 0 40px #0077ff, 0 0 80px #fff;
      margin: 30px 0 20px 0;
      letter-spacing: 4px;
      animation: glow 3s ease-in-out infinite alternate;
      position: relative;
      z-index: 1;
    }

    @keyframes glow {
      from { text-shadow: 0 0 15px #00eaff, 0 0 40px #0077ff, 0 0 60px #fff; }
      to   { text-shadow: 0 0 25px #fff, 0 0 50px #00eaff, 0 0 90px #0077ff; }
    }

    button {
      background: linear-gradient(135deg, #001122, #002244);
      color: #00eaff;
      border: 2px solid #00eaff;
      border-radius: 40px;
      padding: 14px 34px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      margin: 12px 10px;
      transition: all 0.25s ease-in-out;
      box-shadow: 0 0 10px #00eaff;
      position: relative;
      z-index: 1;
    }

    button:hover {
      transform: scale(1.1);
      box-shadow: 0 0 20px #00eaff, 0 0 40px #0077ff;
      background: linear-gradient(135deg, #002244, #003366);
    }

    .crt-container {
      position: relative;
      display: inline-block;
      margin: 30px auto 20px auto;
      max-width: 95vw;
      z-index: 1;
    }

    canvas {
      display: block;
      background: rgba(0,0,0,0.7);
      border-radius: 20px;
      border: 3px solid #00eaff;
      box-shadow: 0 0 20px #0077ff, 0 0 40px #00eaff;
    }

    /* Scanlines + flicker CRT */
    .crt-overlay {
      pointer-events: none;
      position: absolute;
      inset: 0;
      border-radius: 20px;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,0.05) 0px,
        rgba(255,255,255,0.05) 1px,
        transparent 2px,
        transparent 4px
      );
      animation: flicker 0.12s infinite;
    }

    @keyframes flicker {
      0%, 100% { opacity: 0.1; }
      50% { opacity: 0.18; }
    }

    .bombillas {
      display: flex;
      justify-content: center;
      gap: 48px;
      margin-top: 30px;
      flex-wrap: wrap;
      position: relative;
      z-index: 1;
    }

    .bombilla {
      width: 90px;
      height: 90px;
      border-radius: 50%;
      background: radial-gradient(circle, #111 40%, #000 100%);
      border: 2px solid #00eaff;
      box-shadow: 0 0 15px #0077ff inset, 0 0 25px #00eaff;
      transition: all 0.25s ease-in-out;
    }
    .bombilla.active {
      transform: scale(1.2);
      box-shadow: 0 0 20px #fff, 0 0 40px #00eaff, 0 0 60px #0077ff;
      background: radial-gradient(circle, #00eaff 20%, #001122 100%);
    }
	
	.spacer {
		height: 80px; /* espacio vac√≠o arriba */
	}

  </style>
</head>
<body>
  <h1></h1>
  <div class="spacer"></div>
  <button onclick="start()">üéôÔ∏è Activar micr√≥fono</button>
  <button onclick="playSeq(1)">‚ñ∂ Nivel 1</button>
  <button onclick="playSeq(2)">‚ñ∂ Nivel 2</button>
  <button onclick="playSeq(3)">‚ñ∂ Nivel 3</button>
  <button onclick="playSeq(4)">‚ñ∂ Nivel 4</button>
  <button onclick="playSeq(5)">‚ñ∂ Nivel Final</button>
  

	<!-- Botones para notas individuales -->
	<div>
	  <button onclick="playNote('C')">P1</button>
	  <button onclick="playNote('Eb')">P2</button>
	  <button onclick="playNote('F')">P3</button>
	  <button onclick="playNote('G')">P4</button>
	  <button onclick="playNote('Bb')">P5</button>
	</div>


  <!-- CRT container -->
  <div class="crt-container">
    <canvas id="canvas" width="1000" height="500"></canvas>
    <div class="crt-overlay"></div>
  </div>
  
    <div class="bombillas">
    <div><div id="bombilla1" class="bombilla"></div></div>
    <div><div id="bombilla2" class="bombilla"></div></div>
    <div><div id="bombilla3" class="bombilla"></div></div>
    <div><div id="bombilla4" class="bombilla"></div></div>
    <div><div id="bombilla5" class="bombilla"></div></div>
  </div>

  <script>
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  let audioCtx, analyser;

  // Variables globales de volumen
  let micVolume = 200.0;       // Volumen del micro (ej: 0.5 = menos, 2.0 = m√°s fuerte)
  let internalVolume = 0.7;  // Volumen de osciladores internos

    const notas = {
      "C": 2*261.63, "Eb": 2*311.13,
      "F": 2*349.23, "G": 2*392.00,
      "Bb": 2*466.16
    };

    const niveles = {
      1: [["C",1],["Eb",1],["F",1],["G",1],["Bb",2],["G",0.9],["F",0.9],["Eb",0.9],["C",2]],
      2: [["F",1.5],["F",1.5],["Eb",0.5],["F",0.5],["G",0.5],["C",1.5],["Eb",1.5]],
      3: [["Bb",0.9],["G",0.9],["F",0.9],["Eb",0.9],["F",2]],
      4: [["F",1.5],["F",1.5],["Eb",0.5],["F",0.5],["G",0.5],["C",1.5],["Eb",1.5],
          ["Bb",0.9],["G",0.9],["F",0.9],["Eb",0.9],["F",2]],
      5: [["F",1.5],["F",1.5],["Eb",0.5],["F",0.5],["G",0.5],["C",1],["Eb",1.5],
          ["F",1.5],["F",1.5],["Eb",0.5],["F",0.5],["G",0.5],["C",1],["Eb",1.5],
          ["Bb",0.9],["G",0.9],["F",0.9],["Eb",0.9],
          ["Bb",0.9],["G",0.9],["F",0.9],["Eb",0.9],["F",2]]
    };

    const bpm = 168;
    const dur_negra = 60 / bpm;

    const bombillas = {
      C: document.getElementById("bombilla1"),
      Eb: document.getElementById("bombilla2"),
      F: document.getElementById("bombilla3"),
      G: document.getElementById("bombilla4"),
      Bb: document.getElementById("bombilla5")
    };

    async function start() {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const source = audioCtx.createMediaStreamSource(stream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 8192;

      // NUEVO: control de volumen del micro
      const micGain = audioCtx.createGain();
      micGain.gain.value = micVolume;
      source.connect(micGain);
      micGain.connect(analyser);

      const dataArray = new Uint8Array(analyser.frequencyBinCount);
      const binWidth = audioCtx.sampleRate / analyser.fftSize;
      const minFreq = 100, maxFreq = 2000;
      const minBin = Math.floor(minFreq / binWidth);
      const maxBin = Math.ceil(maxFreq / binWidth);

      function draw() {
        requestAnimationFrame(draw);
        analyser.getByteFrequencyData(dataArray);

        ctx.fillStyle = "#000";
        ctx.fillRect(0,0,canvas.width,canvas.height);

        const visibleBins = maxBin - minBin;
        for (let i = minBin; i < maxBin; i++) {
          const barHeight = Math.pow(dataArray[i] / 255, 2) * (canvas.height - 60);
          const x = (i - minBin) * (canvas.width / visibleBins);
          ctx.fillStyle = `rgba(0, 217, 255, ${(dataArray[i]/255).toFixed(2)})`;
          ctx.fillRect(x, canvas.height - barHeight, 3, barHeight);
        }
      }
      draw();
    }

    function getColor(nota) {
      switch(nota) {
        case "C": return "#00d9ff";
        case "Eb": return "#0077ff";
        case "F": return "#fff";
        case "G": return "#66ccff";
        case "Bb": return "#3399ff";
      }
    }

    function playSeq(nivel = 1) {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      let t = audioCtx.currentTime;
      const melodia = niveles[nivel];

      melodia.forEach(([nota, dur]) => {
        let osc = audioCtx.createOscillator();
        let gain = audioCtx.createGain();
        gain.gain.value = internalVolume; // volumen de nota interna
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        gain.connect(analyser);
        osc.type = "sine";
        osc.frequency.value = notas[nota];

        setTimeout(() => {
          const b = bombillas[nota];
          if (b) {
            b.classList.add("active");
            b.style.background = getColor(nota);
            setTimeout(() => {
              b.classList.remove("active");
              b.style.background = "radial-gradient(circle, #111 40%, #000 100%)";
            }, dur*dur_negra*1000);
          }
        }, (t - audioCtx.currentTime) * 1000);

        osc.start(t);
        osc.stop(t + dur * dur_negra);
        t += dur * dur_negra + 0.05;
      });
    }
	
    function playNote(nota) {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      let osc = audioCtx.createOscillator();
      let gain = audioCtx.createGain();
      gain.gain.value = internalVolume; // volumen de nota interna
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      if (analyser) gain.connect(analyser);

      osc.type = "sine";
      osc.frequency.value = notas[nota];
      osc.start();
      osc.stop(audioCtx.currentTime + 0.8); // duraci√≥n de ~0.8s

      // Animar bombilla correspondiente
      const b = bombillas[nota];
      if (b) {
        b.classList.add("active");
        b.style.background = getColor(nota);
        setTimeout(() => {
          b.classList.remove("active");
          b.style.background = "radial-gradient(circle, #111 40%, #000 100%)";
        }, 800);
      }
    }

    // üéµ M√∫sica de fondo independiente
    const backgroundSong = new Audio("blinding.mp3");
    document.addEventListener("keydown", (event) => {
      if (event.code === "Space") {
        backgroundSong.currentTime = 0;
        backgroundSong.play();
      }
    });
  </script>
</body>
</html>

